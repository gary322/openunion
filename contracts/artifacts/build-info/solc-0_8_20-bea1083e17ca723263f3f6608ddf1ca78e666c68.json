{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-bea1083e17ca723263f3f6608ddf1ca78e666c68",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/PayoutSplitter.sol": "project/contracts/PayoutSplitter.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PayoutSplitter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @notice Minimal payout splitter that atomically transfers net+fee in a single transaction.\n/// The payer is `msg.sender` (the off-chain signer / treasury wallet). The payer must approve\n/// this contract to spend USDC before calling `payout`.\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ncontract PayoutSplitter {\n    event Payout(\n        address indexed token,\n        address indexed payer,\n        address indexed worker,\n        address platform,\n        uint256 netAmount,\n        uint256 feeAmount\n    );\n\n    event PayoutV2(\n        address indexed token,\n        address indexed payer,\n        address indexed worker,\n        address platform,\n        address proofwork,\n        uint256 netAmount,\n        uint256 platformFeeAmount,\n        uint256 proofworkFeeAmount\n    );\n\n    bool public paused;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not_owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setPaused(bool v) external onlyOwner {\n        paused = v;\n    }\n\n    /// @notice Transfers `net` to `worker` and `fee` to `platform` from `msg.sender`.\n    function payout(address token, address worker, address platform, uint256 net, uint256 fee) external {\n        require(!paused, \"paused\");\n        require(worker != address(0) && platform != address(0), \"bad_address\");\n\n        if (net > 0) {\n            require(IERC20(token).transferFrom(msg.sender, worker, net), \"net_transfer_failed\");\n        }\n        if (fee > 0) {\n            require(IERC20(token).transferFrom(msg.sender, platform, fee), \"fee_transfer_failed\");\n        }\n\n        emit Payout(token, msg.sender, worker, platform, net, fee);\n    }\n\n    /// @notice Transfers `net` to `worker`, `platformFee` to `platform` and `proofworkFee` to `proofwork` from `msg.sender`.\n    /// Platform is optional only when `platformFee == 0` (platform can be address(0) in that case).\n    function payoutV2(\n        address token,\n        address worker,\n        address platform,\n        address proofwork,\n        uint256 net,\n        uint256 platformFee,\n        uint256 proofworkFee\n    ) external {\n        require(!paused, \"paused\");\n        require(worker != address(0) && proofwork != address(0), \"bad_address\");\n        if (platformFee > 0) {\n            require(platform != address(0), \"bad_platform\");\n        }\n\n        if (net > 0) {\n            require(IERC20(token).transferFrom(msg.sender, worker, net), \"net_transfer_failed\");\n        }\n        if (platformFee > 0) {\n            require(IERC20(token).transferFrom(msg.sender, platform, platformFee), \"platform_fee_transfer_failed\");\n        }\n        if (proofworkFee > 0) {\n            require(IERC20(token).transferFrom(msg.sender, proofwork, proofworkFee), \"proofwork_fee_transfer_failed\");\n        }\n\n        emit PayoutV2(token, msg.sender, worker, platform, proofwork, net, platformFee, proofworkFee);\n    }\n}\n"
      }
    }
  }
}